import { NativeModules, NativeEventEmitter } from 'react-native';
import { makeUFSErrorFromReactError } from '../../../../JSCore';
const DataBus = NativeModules.UFSDataBusBridge;
const DataBusEventEmitter = new NativeEventEmitter(DataBus);
const DataBusEvents = DataBus.DataBusEvents;
export const UFSDataBusMessageType = DataBus.MessageType;
/**
 * Компонент предоставляет набор методов, которые можно использовать для общения между javascript-приложениями, находящимися в разных бандлах.
 * @category Nonvisual
 */
export default class UFSDataBus {
    /**
     * Метод регистрирует компонент в `DataBus`.
     * Отправка и получение компонентом сообщений возможны только после вызова данного метода.
     *
     * **Входные параметры:**
     * - `callback` - функция, которая будет вызвана при получении компонентом сообщения.
     * В качестве параметра передаётся массив сообщений.
     * При получении online-сообщений массив содержит только один элемент.
     * При получении offline-сообщений массив содержит всю накопившуюся очередь.
     * **Возвращаемые значения:**
     * - Promise - JS-объект типа Promise с состояниями:
     *   - `resolve(result: DataBusRegisterResult)` - в случае успеха возвращаются `bundleName` и `appId` зарегистированного компонента
     *   - `rejected(error: UFSError)` - не удалось зарегистрировать компонент. На текущий момент регистрация компонента не может завершиться неудачно.
     * @static
     */
    static register(callback) {
        return new Promise((resolve, reject) => {
            DataBus.registerApplication()
                .then((result) => {
                UFSDataBus.subscribeOnRecieveMessage(callback);
                DataBus.checkMessageQueue();
                resolve(result);
            })
                .catch((error) => {
                reject(makeUFSErrorFromReactError(error));
            });
        });
    }
    /**
     * Метод отправляет сообщение заданным javascript-приложениям.
     * Чтобы отправить сообщение незарегистрированному приложению, необходимо передать значение `OFFLINE` в параметр `messageType`.
     * При отправке сообщений незарегистрированному приложению,
     * сообщения помещаются в очередь по `bundleName`. Очередь хранится в оперативной памяти (при перезагрузке iOS-приложения она будет очищена).
     *
     * Когда будет вызван метод `register` для приложения с таким `bundleName`,
     * все сообщения, помещённые в очередь для данного бандла будут ему отправлены.
     *
     * Для отправки массового сообщения всем зарегистрированным компонентам параметры `toBundleName` и `toAppId` следует опустить (передать в них `undefined`).
     *
     * #### Обратите внимание
     * + Очередь накопленных offline-сообщений будет отправлена первому приложению с целевым `bundleName`,
     * которое будет зарегистрировано в `DataBus`, а затем очередь будет очищена.
     * Таким образом, если в DataBus зарегистрируется ещё одно приложение с аналогичным bundleName, ему ничего не будет отправлено.
     * + Broadcast-сообщения доставляются только тем приложениям, которые на момент отправки находятся онлайн.
     *
     * <br>
     * **Входные параметры:**
     * - `payload` - произвольная прикладная информация;
     * - `toBundleName` - название бандла адресата;
     * - `toAppId` - уникальный `appId` адресата. Для успешной отправки с использованием этого параметра должен быть заполнен вместе с именем бандла;
     * - `messageType` - тип сообщения из справочника `DataBusMessageType`. Доступные значения:
     *   - `ONLINE` - отправка сообщений зарегистрированным приложениям;
     *   - `OFFLINE` - отправка сообщений незарегистрированным приложениям.
     *
     * **Возвращаемые значения:**
     * - Promise - JS-объект типа Promise с состояниями:
     *   - `resolve()` - успешная отправка сообщения
     *   - `rejected(error: UFSError)` - сообщение не удалось отправить. Возможные коды ошибок:
     *     - `UFSDataBusServiceErrorCodeBundleNameIsNotSpecified`
     *     - `UFSDataBusServiceErrorCodePayloadExceedsLimit`
     *     - `UFSDataBusServiceErrorCodeComponentNotRegistered`
     *     - `UFSDataBusServiceErrorCodeBroadcastMessageUnavailable`
     *     - `UFSDataBusServiceErrorCodeHasNoMessageReciever`
     * @static
     */
    static sendMessage(payload, toBundleName, toAppId, messageType = UFSDataBusMessageType.ONLINE) {
        return new Promise((resolve, reject) => {
            DataBus.sendMessage(payload, toBundleName, toAppId, messageType)
                .then(() => {
                resolve();
            })
                .catch((error) => {
                reject(makeUFSErrorFromReactError(error));
            });
        });
    }
    /**
     * @private
     * @static
     */
    static subscribeOnRecieveMessage(callback) {
        let mappedCallback = (nativeResponse) => {
            var mappedMessages = nativeResponse.map(function (nativeMessage) {
                let object = Object.assign({}, nativeMessage, {
                    time: new Date(nativeMessage.timestamp * 1000)
                });
                delete object.timestamp;
                return object;
            });
            callback(mappedMessages);
        };
        DataBusEventEmitter.addListener(DataBusEvents.didRecieveMessage, mappedCallback, undefined);
    }
}
//# sourceMappingURL=UFSDataBus.js.map