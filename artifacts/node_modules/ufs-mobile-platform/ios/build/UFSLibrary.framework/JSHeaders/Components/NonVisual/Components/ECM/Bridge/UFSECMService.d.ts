export declare type FileInfo = string | {
    fileId: string;
    fileName: string;
};
/**
 * + `type` - тип политики кеширования. Возможные значения:
 *   + `CACHE` - будет использоваться файловый кэш;
 *   + `DIRECT` - документ будет выгружен из ECM с последующей перекладкой в Sigma.
 * + `maxTTL` - максимальное время жизни документа в файловом кэше.
 */
export interface ECMCachePolicy {
    type: 'CACHE' | 'DIRECT';
    maxTTL?: number;
}
/**
 * + `downloadURL` - URL сервера, на который будет отправляться download-запрос.
 * + `statusURL` - URL сервера, на который будет отправляться getStatus-запрос.
 * + `fileURL` - URL сервера, с которого будет происходить скачивание файла. Должен обязательно оканчиваться на "/" для корректного формирования ссылки на файл.
 * + `cachePolicy` - опциональный ключ в случае, если он будет задан в методе `get`, в ином случае - обязательный ключ.
 * + `user` - имя текущего СУДИР-пользователя.
 * + `maxRetryCount` - максимальное количество попыток получения статуса (отправлений getStatus-запросов). По умолчанию значение равно `30`.
 * + `pollingTimeout` - время ожидания в секундах между getStatus-запросами. По умолчанию значение равно `30`.
 * + `shouldReturnObject` - если флаг выставлен как `false`,
 * то в случае успешного выполнения метода `get` будет возвращено значение `fileId` в виде простой строки.
 * Если флаг выставлен как `true`, то в случае успешного выполнения метода `get` будет возвращён объект типа `FileInfo`.
 */
export interface ECMConfig {
    downloadURL: string;
    statusURL: string;
    fileURL: string;
    cachePolicy?: ECMCachePolicy;
    user?: string;
    maxRetryCount?: number;
    pollingTimeout?: number;
    shouldReturnObject?: boolean;
}
/**
 * + `scenarioId` - уникальный идентификатор сценария ТФС.
 * + `fileId` - идентификатор документа в ECM.
 * + `cachePolicy` - является опциональным ключом в случае, если он был задан в методе `configure`,
 * в ином случае - обязательный ключ. Если `cachePolicy` задан одновременно в методах `get` и `configure`, то приоритет будет у `get`-метода.
 * + `user` - имя текущего СУДИР-пользователя.
 */
export interface ECMGetInfo {
    scenarioId: string;
    fileId: string;
    cachePolicy?: ECMCachePolicy;
    user?: string;
}
/**
 * Возможные шаги процесса загрузки файла из ECM.
 * + `FileTransfer` - файл перекладывается из сети Alpha в Sigma.
 * + `FileDownload` - файл загружается непосредственно на целевое устройство.
 */
export declare enum ECMStep {
    FileTransfer = 0,
    FileDownload = 1,
}
/**
 * + `expectedContentLength` - ожидаемый размер файла в байтах.
 * + `handledContentLength` - обработанный размер файла в байтах.
 * + `step` - шаг процесса загрузки файла.
 */
export interface ECMProgress {
    expectedContentLength: number;
    handledContentLength: number;
    step: ECMStep;
}
/**
 * Компонент упрощает выполнение типовой интеграции с ECM за счёт предоставления упрощённого API.
 *
 * Компонент работает по сконфигурированным параметрам.
 *
 * Выстраивание правильной инфраструктуры для взаимодействия мобильного устройства с ECM через Sigma/DP/Alpha/КСШ не входит в задачу данного компонента.
 *
 * Компонент работает с абстрактным заданным back-end.
 *
 * С деталями интеграции с ECM можно ознакоситься в [документе "Сервис файлового обмена в ЕСМ"](https://sbtatlas.sigma.sbrf.ru/wiki/pages/viewpage.action?pageId=84730204#id-ПлатформаЕФС-Мобильнаяплатформа).
 * @category Nonvisual
 */
export default class UFSECMService {
    /**
     * Метод не реализован. На текущий момент он ничего не делает и всегда возвращает `success`.
     * @private
     * @static
     */
    static send(fileId: string, info: Object): Promise<void>;
    /**
     * Метод позволяет скачивать файлы с ECM-сервиса на устройство.
     *
     * **Входные параметры:**
     * - `info` - объект с информацией о запрашиваемом файле;
     * - `progress` - колбек вызывается с некоторой периодичностью во время процесса загрузки файла. В качестве параметра передаётся прогресс загрузки.
     *
     * **Возвращаемые значения:**
     * - Promise - JS-объект типа Promise с состояниями:
     *   - Если `shouldReturnObject == false`:
     *     - `resolve(fileID: string)` - операция завершена успешно: файл загружен на устройство и ему присвоен `fileID`, возвращённый в блок `resolve`.
     *     - `rejected(error: UFSError)` - операция завершилась неудачно.
     *   - Если `shouldReturnObject == true`:
     *     - `resolve(fileInfo: FileInfo)` - операция завершена успешно: файл загружен на устройство и ему присвоен `fileID`, возвращается объект типа `FileInfo`.
     *     - `rejected(error: UFSError)` - операция завершилась неудачно.
     * Если имя файла доступно на момент возникновения ошибки, то в объекте ошибки будет присутствовать поле `fileName` с именем файла ECM. Возможные коды ошибок:
     *       - `UFSECMServiceErrorCodeUndefinedDownloadURL`
     *       - `UFSECMServiceErrorCodeUndefinedStatusURL`
     *       - `UFSECMServiceErrorCodeUndefinedFileURL`
     *       - Вложенный `NSError`
     * @static
     */
    static get(info: ECMGetInfo, progress?: (progress: ECMProgress) => void): Promise<string | FileInfo>;
    /**
     * Метод позволяет задать базовые настройки для работы с ECM-сервисом.
     * Время жизни заданных настроек ограничено временем жизни приложения,
     * т.е при каждом новом запуске приложения данные настройки необходимо задавать заново.
     *
     * **Входные параметры:**
     * - `config` - объект конфигурации.
     *
     * **Возвращаемые значения:**
     * - Promise - JS-объект типа Promise с состояниями:
     *   - `resolve()` - операция завершена успешно, компонент по работе с ECM сконфигурирован.
     *   - `rejected(error: UFSError)` - операция завершилась неудачно. На текущий момент операция не может завершиться неудачно.
     * @static
     */
    static configure(config: ECMConfig): Promise<void>;
    private static unsubscribe(subscription);
    private static subscribeOnReceiveProgressMessage(progress?);
}
