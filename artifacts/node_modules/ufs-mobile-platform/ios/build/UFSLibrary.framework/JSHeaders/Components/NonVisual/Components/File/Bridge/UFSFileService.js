import { NativeModules } from 'react-native';
import { makeUFSErrorFromReactError } from '../../../../JSCore';
const FileService = NativeModules.UFSFileServiceBridge;
export const UFSFileType = FileService.FileTypes;
export const UFSPersistentType = FileService.PersistentTypes;
/**
 * Компонент предоставляет набор методов для работы с файлами.
 *
 * Библиотека абстрагирует прикладной код от физического расположения файлов на жестком диске, путем использования уникальных идентификаторов файла (fileId).
 * Благодаря этому обеспечивается оптимальная производительность.
 * Также это означает что большинство методов по работе с файлами принимают идентификатор в качестве параметра.
 * @category Nonvisual
 */
export default class UFSFileService {
    /**
     * Метод создает новый пустой файл. Файлы создаются с типом персистентности `PERSISTENT`.
     *
     * **Входные параметры:**
     * - `name` - имя файла. На данный момент параметр ни на что не влияет.
     * - `type` - тип файла из словаря FileType.
     *
     * **Возвращаемые значения:**
     * - Promise - JS-объект типа Promise с состояниями:
     *   - `resolve(fileID: string)` - операция завершена успешно. В блок `resolve` передается идентификатор созданного файла.
     *   - `rejected(error: UFSError)` - операция завершилась неудачно. Возможные коды ошибок:
     *     - Вложенный `NSError`.
     * @static
     */
    static create(name, type) {
        return new Promise((resolve, reject) => {
            FileService.create(name, type)
                .then((fileId) => {
                resolve(fileId);
            })
                .catch((error) => {
                reject(makeUFSErrorFromReactError(error));
            });
        });
    }
    /**
     * Метод добавляет в файл с идентификатором `fileId` переданную строку.
     *
     * **Входные параметры:**
     * - `fileId` - идентификатор файла
     * - `text` - текст для вставки
     *
     * **Возвращаемые значения:**
     * - Promise - JS-объект типа Promise с состояниями:
     *   - `resolve()` - операция завершена успешно, в файл добавлена строка из входного параметра `text`
     *   - `rejected(error: UFSError)` - операция завершилась неудачно. Возможные коды ошибок:
     *     - `UFSFileServiceErrorCodeNotExist` - при отсутствии файла в базе данных;
     *     - `UFSFileServiceErrorCodeDeletedFile` - при существовании файла в базе данных, но отсутствии на диске;
     *     - Вложенный `NSError`.
     * @static
     */
    static append(fileId, text) {
        return new Promise((resolve, reject) => {
            FileService.append(fileId, text)
                .then(() => {
                resolve();
            })
                .catch((error) => {
                reject(makeUFSErrorFromReactError(error));
            });
        });
    }
    /**
     * Метод добавляет в файл с идентификатором `fileId` переданные бинарные данные.
     * ##### Обратите внимание
     * Метод приводит к передачи большого потока данных через мост JS ↔ Objective-C.
     * Для повышения производительности рекомендуется передавать большие блобы бинарных данных с помощью метода `appendBase64`.
     *
     * **Входные параметры:**
     * - `fileId` - идентификатор файла
     * - `content` - Бинарные данные в виде строки, например '01010101'.
     * Если количество символов в строке будет не кратно 8, то строка автоматически дополнятся '0'(например аргумент '1111' превратится в '11110000')
     *
     * **Возвращаемые значения:**
     * - Promise - JS-объект типа Promise с состояниями:
     *   - `resolve()` - операция завершена успешно, в файл добавлены бинарные данные из входного параметра `content`
     *   - `rejected(error: UFSError)` - операция завершилась неудачно. Возможные коды ошибок:
     *     - `UFSFileServiceErrorCodeNotExist` - при отсутствии файла в базе данных;
     *     - `UFSFileServiceErrorCodeDeletedFile` - при существовании файла в базе данных, но отсутствии на диске;
     *     - Вложенный `NSError`.
     * @static
     */
    static appendBinary(fileId, content) {
        return new Promise((resolve, reject) => {
            FileService.appendBinary(fileId, content)
                .then(() => {
                resolve();
            })
                .catch((error) => {
                reject(makeUFSErrorFromReactError(error));
            });
        });
    }
    /**
     * Метод добавляет в файл с идентификатором `fileId` строку, закодированную в формат base64.
     * Декодирование происходит на нативном уровне.
     *
     * **Входные параметры:**
     * - `fileId` - идентификатор файла
     * - `content` - строка, закодированная в формат base64
     *
     * **Возвращаемые значения:**
     * - Promise - JS-объект типа Promise с состояниями:
     *   - `resolve()` - операция завершена успешно, в файл добавлена декодированная строка из входного параметра `content`
     *   - `rejected(error: UFSError)` - операция завершилась неудачно. Возможные коды ошибок:
     *     - `UFSFileServiceErrorCodeNotExist` - при отсутствии файла в базе данных;
     *     - `UFSFileServiceErrorCodeDeletedFile` - при существовании файла в базе данных, но отсутствии на диске;
     *     - Вложенный `NSError`.
     * @static
     */
    static appendBase64(fileId, content) {
        return new Promise((resolve, reject) => {
            FileService.appendBase64(fileId, content)
                .then(() => {
                resolve();
            })
                .catch((error) => {
                reject(makeUFSErrorFromReactError(error));
            });
        });
    }
    /**
     * Метод удаляет файл c идентификатором `fileId` из файловой системы.
     *
     * **Входные параметры:**
     * - `fileId` - идентификатор файла
     *
     * **Возвращаемые значения:**
     * - Promise - JS-объект типа Promise с состояниями:
     *   - `resolve()` - операция завершена успешно, файл удален
     *   - `rejected(error: UFSError)` - операция завершилась неудачно. Возможные коды ошибок:
     *     - `UFSFileServiceErrorCodeNotExist` - при отсутствии файла в базе данных;
     *     - `UFSFileServiceErrorCodeDeletedFile` - при существовании файла в базе данных, но отсутствии на диске;
     *     - Вложенный `NSError`.
     * @static
     */
    static delete(fileId) {
        return new Promise((resolve, reject) => {
            FileService.delete(fileId)
                .then(() => {
                resolve();
            })
                .catch((error) => {
                reject(makeUFSErrorFromReactError(error));
            });
        });
    }
    /**
     * Метод возвращает размер файла с идентификатором `fileId`.
     *
     * **Входные параметры:**
     * - `fileId` - идентификатор файла
     *
     * **Возвращаемые значения:**
     * - Promise - JS-объект типа Promise с состояниями:
     *   - `resolve(size: number)` - операция завершена успешно. В блок `resolve` передается размер файла в байтах
     *   - `rejected(error: UFSError)` - операция завершилась неудачно. Возможные коды ошибок:
     *     - `UFSFileServiceErrorCodeNotExist` - при отсутствии файла в базе данных;
     *     - `UFSFileServiceErrorCodeDeletedFile` - при существовании файла в базе данных, но отсутствии на диске;
     *     - Вложенный `NSError`.
     * @static
     */
    static getSize(fileId) {
        return new Promise((resolve, reject) => {
            FileService.getSize(fileId)
                .then((size) => {
                resolve(size);
            })
                .catch((error) => {
                reject(makeUFSErrorFromReactError(error));
            });
        });
    }
    /**
     * Метод изменяет тип персистентности файла с идентификатором `fileId`. По умолчанию файлы создаются с типом `PERSISTENT`.
     *
     * **Входные параметры:**
     * - `fileId` - идентификатор файла
     * - `persistenceType` - тип персистентности файла из словаря PersistentType. Доступные значения:
     *   - `PERSISTENT` - файл будет перемещен в папку documents и не может быть удален системой
     *   - `TEMP` - файл будет перемещен в папку временных файлов и может быть удален системой при нехватке места
     *
     * **Возвращаемые значения:**
     * - Promise - JS-объект типа Promise с состояниями:
     *   - `resolve()` - операция завершена успешно, тип персистентности изменен
     *   - `rejected(error: UFSError)` - операция завершилась неудачно. Возможные коды ошибок:
     *     - `UFSFileServiceErrorCodeNotExist` - при отсутствии файла в базе данных;
     *     - `UFSFileServiceErrorCodeDeletedFile` - при существовании файла в базе данных, но отсутствии на диске;
     *     - Вложенный `NSError`.
     * @static
     */
    static changePersistency(fileId, persistenceType) {
        return new Promise((resolve, reject) => {
            FileService.changePersistency(fileId, persistenceType)
                .then(() => {
                resolve();
            })
                .catch((error) => {
                reject(makeUFSErrorFromReactError(error));
            });
        });
    }
    /**
     * Метод возвращает полный путь файла с идентификатором `fileId`.
     * ##### Обратите внимание
     * Путь файла стоит использовать только для чтения.
     * Для модификации файла используйте соответствующие доступные методы (`delete`, `changePresistency`).
     *
     * **Входные параметры:**
     * - `fileId` - идентификатор файла
     *
     * **Возвращаемые значения:**
     * - Promise - JS-объект типа Promise с состояниями:
     *   - `resolve(path: string)` - операция завершена успешно. В блок `resolve` передается абсолютный путь файла
     *   - `rejected(error: UFSError)` - операция завершилась неудачно. Возможные коды ошибок:
     *     - `UFSFileServiceErrorCodeNotExist` - при отсутствии файла в базе данных;
     *     - `UFSFileServiceErrorCodeDeletedFile` - при существовании файла в базе данных, но отсутствии на диске;
     *     - Вложенный `NSError`.
     * @static
     */
    static getFilePath(fileId) {
        return new Promise((resolve, reject) => {
            FileService.getFilePath(fileId)
                .then((path) => {
                resolve(path);
            })
                .catch((error) => {
                reject(makeUFSErrorFromReactError(error));
            });
        });
    }
}
//# sourceMappingURL=UFSFileService.js.map