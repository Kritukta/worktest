/**
 *  + `terminalName` - Имя платёжного терминала;
 *  + `terminalMacAddress` - Mac-адресс платёжного терминала;
 *  + `isBluetooth` - Параметр сообщает подключён ли терминал по Bluetooth или нет;
 *  + `terminalIPAddress` - IP-адрес терминала.
 */
export interface ITerminal {
    terminalName?: string;
    terminalMacAddress?: string;
    isBluetooth?: boolean;
    terminalIPAddress?: string;
}
/**
 *  + `sslCertificateName` - Имя сертификата;
 *  + `sslCertificatePassword` - Пароль для сертификата.
 */
export interface ISSLParams {
    sslCertificateName: string;
    sslCertificatePassword: string;
}
/**
 *  + `ipAddress` - IP-адрес сервера. Параметр требуется если соединение iOS-устройства с терминалом устанавливается без использования Bluetooth;
 *  + `port` - Номер порта, используемого для установки соединения между iOS-устройством и терминалом;
 *  + `requestMethod` - Метод HTTP-запроса.
 */
export interface IIngenicoConfigure {
    ipAddress?: string;
    port: number;
    requestMethod: string;
}
/**
 * Сервис предоставляет набор методов для работы с платёжными терминалами Ingenico.
 *
 * <br/>
 * **Настройка проекта**
 *
 * Для приложения, использующего компонент Ingenico, потребуется объявить имена протоколов, используемых для взаимодействия с платёжным терминалом. Список протоколов, поддерживаемых терминалом:
 * + com.ingenico.easypayemv.printer;
 * + com.ingenico.easypayemv.barcodereader;
 * + com.ingenico.easypayemv.spm-transaction;
 * + com.ingenico.easypayemv.spm-configuration;
 * + com.ingenico.easypayemv.spm-networkaccess;
 * + com.ingenico.easypayemv.spm-sppchannel;
 * + com.ingenico.easypayemv.spm-pppchannel.
 *
 * Они должны быть добавлены в файл Info.plist под ключом "Supported external accessory protocols":
 *
 * ![Пример 1](http://sbt-orefs-063.sigma.sbrf.ru/ufsmp/static/documentation/supported_external_accessory_protocols.png "Пример 1")
 *
 * <br/>
 * **Поддерживаемые устройства**
 *
 * Компонент может быть использован для следующих устройств компаньонов (платёжных терминалов):
 * + MFI устройства
 *  - iMP350 (iSMP with barcode reader)
 *  - iMP320(iSMP without barcode reader)
 *  - iMP322 (iSMP Companion without barcode reader) o iMP352 (iSMP Companion with barcode reader)
 *  - iCM122 (iCMP)
 * + другие компаньоны
 *  - iWL22x, iWL25x, iWL28x, where x can be 7, 8, 9, A, B, C (iWL with Wi-Fi connectivity)
 *
 * **Создание пары между iOS-устройством и платёжным терминалом**
 *
 * 1. Включите терминал, зажав кнопку сбоку (для модели терминала iCMP122);
 * 2. Во время загрузки на экране появится кнопка "Меню", необходимо нажать кнопку F4 на терминале до того, как процесс загрузки завершит этот этап;
 * 3. Терминал потребует ввести пароль (уточните пароль у лица, ответственного за терминал);
 * 4. В появившемся меню перейдите в пункт "Системные настройки";
 * 5. Именование пунктов меню для создания пары, с использованием Bluetooth, зависит от версии прошивки терминала (уточните последовательность у лица, ответственного за терминал).
 *
 * Если вы испытываете затруднения в использовании терминала, обратитесь к лицу, ответственному за терминал.
 * @category Nonvisual
 */
export default class UFSIngenicoService {
    /**
     * Метод позволяет задать базовые настройки для работы с сервисом Ingenico.
     *
     * **Входные параметры:**
     * - `params` - объект конфигурации
     *
     * **Возвращаемые значения:**
     * отсутствуют
     * @static
     */
    static configure(params: IIngenicoConfigure): void;
    /**
     * Метод позволяет получить список доступных, в настоящий момент, терминалов. Метод возвращает терминалы, соединенные с iOS-устройсвом по Bluetooth и терминалы, видимые по сети. Обратите внимание, что "терминалы, соединенные с iOS-устройсвом по Bluetooth" означает не только те терминалы, с которыми iOS-устройство создало пару.
     *
     * **Входные параметры:**
     * - `callback` - функция вызывается по итогам работы метода. В качестве параметра ей будет передан массив найденных терминалов.
     *
     * **Возвращаемые значения:**
     * отсутствуют
     * @static
     */
    static getAvailableTerminals(callback: (terminals?: Array<ITerminal>) => void): void;
    /**
     * Метод позволяет определить терминал, который вы хотите использовать, из списка доступных.
     *
     * **Входные параметры:**
     * - `terminal` - описывающий терминал, с которым предполагается дальнейшая работа. Используйте в качестве параметра один из элементов массива, полученного в результате выполнения метода getAvailableTerminals
     * - `callback` - функция вызывается по итогам работы метода. В качестве параметра ей будет передан терминал, описывающий выбранный в качестве желаемого для дальнейшей работы. В случае, если не удалось выбрать, переданный в функцию терминал, в качестве желаемого для дальнейшей работы, функция вернет undefined.
     *
     * **Возвращаемые значения:**
     * отсутствуют
     * @static
     */
    static selectTerminal(terminal?: ITerminal, callback?: (terminal?: ITerminal) => void): void;
    /**
     * Чтобы начать общение с терминалом, сначала необходимо запустить Payment Communication Layer (набор библиотек используемых при разработке приложения осуществляющего взаимодействие с платежным терминалом). Эту операцию выполняет метод connectTerminal.
     *
     * **Входные параметры:**
     * отсутствуют
     *
     * **Возвращаемые значения:**
     * - Promise - JS-объект типа Promise с состояниями:
     *   - `resolve()` - операция завершена успешно, соединение с терминалом установлено
     *   - `rejected(error: UFSError)` - операция завершилась неудачно. Возможные коды ошибок:
     *     - `UFSIngenicoComponentErrorCodePclServiceStoped` - сервер остановлен;
     *     - `UFSIngenicoComponentErrorCodePclServiceFailedOnCNX` - сервер не может стартовать из-за отсутствия Wi-Fi;
     *     - `UFSIngenicoComponentErrorCodePclServiceFailedInternal` - сервер не может стартовать из-за внутренней ошибки.
     * @static
     */
    static connectTerminal(): Promise<void>;
    /**
     * Мобильная библиотека, на основании библиотек PCL, предоставляет возможность защитить соединение между терминалом и iOS-устройством. Для создания защищённого соединения, требуется файл .p12 содержащий необходимую информацию. Файл .p12 должен быть включён в проект как ресурс.
     *
     * ![Пример 2](http://sbt-orefs-063.sigma.sbrf.ru/ufsmp/static/documentation/certificate.png "Пример 2")
     *
     * **Входные параметры:**
     * - `sslParams` - объект настройки защищенного соединения
     *
     * **Возвращаемые значения:**
     * - Promise - JS-объект типа Promise с состояниями:
     *   - `resolve()` - операция завершена успешно, соединение с терминалом установлено
     *   - `rejected(error: UFSError)` - операция завершилась неудачно. Возможные коды ошибок:
     *     - `UFSIngenicoComponentErrorCodePclServiceStoped` - сервер остановлен;
     *     - `UFSIngenicoComponentErrorCodePclServiceFailedOnCNX` - сервер не может стартовать из-за отсутствия Wi-Fi;
     *     - `UFSIngenicoComponentErrorCodePclServiceFailedInternal` - сервер не может стартовать из-за внутренней ошибки.
     * @static
     */
    static connectTerminalWithSecurity(sslParams: ISSLParams): Promise<void>;
    /**
     * Метод позволяет послать сообщение (команду на выполнение) терминалу. Уточняйте команды, которые способен обработать терминал, у лица, ответственного за терминал. Общению между iOS-устройством и терминалом осуществляется по HTTP-протоколу.
     *
     * **Входные параметры:**
     * - `header` - поля HTTP-заголовка
     * - `body` - тело HTTP-запроса
     *
     * **Возвращаемые значения:**
     * - Promise - JS-объект типа Promise с состояниями:
     *   - `resolve(data: Object)` - операция завершена успешно, полученный ответ от терминала содержится в объекте `data`;
     *   - `rejected(error: UFSError)` - операция завершилась неудачно. Возможные коды ошибок:
     *     - `UFSIngenicoComponentErrorCodeNoAvailableBridges` - отсутствует доступный bridge;
     *     - `UFSIngenicoComponentErrorCodeThreadCreationIssue` - возникли проблемы при создании потока;
     *     - `UFSIngenicoComponentErrorCodeBridgeInitializationFailed` - не удалось инициализировать bridge.
     * @static
     */
    static send(header: Object, body: Object): Promise<void>;
}
