import { NativeModules } from 'react-native';
import { makeUFSErrorFromReactError } from '../../../../JSCore';
const NetworkService = NativeModules.UFSNetworkServiceBridge;
/**
 * Компонент предоставляет доступ к информации о сетевых настройках.
 *
 * Также компонент предоставляет методы для сетевого взаимодействия, которые конфигурируются объектом, реализующим `NetworkConfig`.
 * Эти методы экспортируются отдельно и описаны в соответствующих разделах.
 * @category Nonvisual/Network
 */
export default class UFSNetworkService {
    /**
     * Метод предоставляет доступ к информации о сетевых настройках.
     * ##### Обратите внимание
     * Для доступа к параметрам они должны быть предварительно прописаны в настройках приложения - в файле `Info.plist`.
     * Значения настроек располагаются по следующему пути: `UFSProjectConfig.baseURL`.
     *
     * #### Предусмотренные поля для UFSProjectConfig.baseURL
     *
     * `Protocol` (тип `String`) - протокол соединения;
     *
     * `Domain` (тип `String`) - домен ресурса;
     *
     * `Port` (тип `String`) - порт соединения.
     *
     * ![Пример 1](http://sbt-orefs-063.sigma.sbrf.ru/ufsmp/static/documentation/network_settings.png "Пример 1")
     *
     * #### Доступ к параметрам из приложения "Настройки"
     * Операционная система `iOS` позволяет просматривать отдельные настройки приложений из приложения "Настройки".
     * Для этого необходимо в `Settings.bundle` (создается из шаблонов `Xcode`) в файл `Root.plist`
     * добавить секции описания полей, соответствующие полям в секции `UFSProjectConfig.baseURL` файла `Info.plist` вашего приложения.
     * Значениями поля `Identifier` для свойств `protocol`, `domain`, `port` являются `baseURLProtocol`, `baseURLDomain`, `baseURLPort` соответственно.
     *
     * Подробнее про `Settings.bundle` можно прочитать
     * [тут](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/UserDefaults/Preferences/Preferences.html).
     *
     * ![Пример 2](http://sbt-orefs-063.sigma.sbrf.ru/ufsmp/static/documentation/settings_props.png "Пример 2")
     *
     * **Входные параметры:**
     * - `callback` - функция, которая вызывается по результатам работы метода.
     * В качестве параметра в эту функцию передаётся объект типа `UrlInfo`, который содержит в себе информацию о сетевых настройках.
     *
     * **Возвращаемые значения:**
     * отсутствуют
     * @static
     */
    static urlInfo(callback) {
        return NetworkService.urlInfo(callback);
    }
}
/**
 * Метод позволяет загружать файлы на устройство.
 * По умолчанию все файлы скачиваются во
 * [временную директорию](https://developer.apple.com/reference/foundation/nssearchpathdirectory/nscachesdirectory)
 * контейнера приложения, которая отведена операционной системой.
 *
 * ##### Обратите внимание
 * `NSCachesDirectory` может быть очищена операционной системой.
 * Данная директория не предназначена для постоянного хранения файлов на жёстком диске.
 *
 * **Входные параметры:**
 * - `url` - ссылка на файл;
 * - `config` - конфигурация сетевого запроса.
 *
 * **Возвращаемые значения:**
 * - Promise - JS-объект типа Promise с состояниями:
 *   - `resolve(fileId: string)` - операция завершена успешно, файл загружен на устройство и ему присовен fileID, возвращенный в блок resolve.
 *   - `rejected(error: UFSError)` - операция завершилась неудачно. Возможные коды ошибок:
 *     - Вложенный `NSError`
 * @category Nonvisual/Network
 */
export function download(url, config) {
    return new Promise((resolve, reject) => {
        NetworkService.downloadFile(url, config)
            .then((fileId) => {
            resolve(fileId);
        })
            .catch((error) => {
            reject(makeUFSErrorFromReactError(error));
        });
    });
}
/**
 * Метод позволяет загружать файлы на удалённый сервер.
 *
 * **Входные параметры:**
 * - `url` - ссылка на файл;
 * - `fileID` - идентификатор файла;
 * - `config` - конфигурация сетевого запроса.
 *
 * **Возвращаемые значения:**
 * - Promise - JS-объект типа Promise с состояниями:
 *   - `resolve()` - операция завершена успешно, файл загружен на удалённый сервер.
 *   - `rejected(error: UFSError)` - операция завершилась неудачно. Возможные коды ошибок:
 *     - Вложенный `NSError`
 * @category Nonvisual/Network
 */
export function upload(url, fileID, config) {
    return new Promise((resolve, reject) => {
        NetworkService.uploadFile(url, fileID, config)
            .then(() => {
            resolve();
        })
            .catch((error) => {
            reject(makeUFSErrorFromReactError(error));
        });
    });
}
/**
 * Метод отправляет GET-запрос на удалённый сервер.
 *
 * **Входные параметры:**
 * - `url` - адрес сервера;
 * - `config` - конфигурация сетевого запроса.
 *
 * **Возвращаемые значения:**
 * - Promise - JS-объект типа Promise с состояниями:
 *   - `resolve(data: Object)` - операция завершена успешно. В блок `resolve` передаются данные, полученные от сервера.
 *   - `rejected(error: UFSError)` - операция завершилась неудачно. Возможные коды ошибок:
 *     - Вложенный `NSError`
 * @category Nonvisual/Network
 */
export function get(url, config) {
    return new Promise((resolve, reject) => {
        NetworkService.get(url, config)
            .then((data) => {
            resolve(data);
        })
            .catch((error) => {
            reject(makeUFSErrorFromReactError(error));
        });
    });
}
/**
 * Метод отправляет POST-запрос на удалённый сервер.
 * Объект, содержащий тело POST-запроса, перед отправкой, сериализуется в JSON-структуру.
 *
 * **Входные параметры:**
 * - `url` - адрес сервера;
 * - `data` - тело запроса;
 * - `config` - конфигурация сетевого запроса.
 *
 * **Возвращаемые значения:**
 * - Promise - JS-объект типа Promise с состояниями:
 *   - `resolve(data: Object)` - операция завершена успешно. В блок `resolve` передаются данные, полученные от сервера.
 *   - `rejected(error: UFSError)` - операция завершилась неудачно. Возможные коды ошибок:
 *     - `UFSNetworkServiceErrorCodeInvalidJSON`
 *     - Вложенный `NSError`
 * @category Nonvisual/Network
 */
export function post(url, data, config) {
    return new Promise((resolve, reject) => {
        NetworkService.post(url, data, config)
            .then((data) => {
            resolve(data);
        })
            .catch((error) => {
            reject(makeUFSErrorFromReactError(error));
        });
    });
}
/**
 * Метод отправляет PUT-запрос на удалённый сервер.
 * Объект, содержащий тело PUT-запроса, перед отправкой, сериализуется в JSON-структуру.
 *
 * **Входные параметры:**
 * - `url` - адрес сервера;
 * - `data` - тело запроса;
 * - `config` - конфигурация сетевого запроса.
 *
 * **Возвращаемые значения:**
 * - Promise - JS-объект типа Promise с состояниями:
 *   - `resolve(data: Object)` - операция завершена успешно. В блок `resolve` передаются данные, полученные от сервера.
 *   - `rejected(error: UFSError)` - операция завершилась неудачно. Возможные коды ошибок:
 *     - `UFSNetworkServiceErrorCodeInvalidJSON`
 *     - Вложенный `NSError`
 * @category Nonvisual/Network
 */
export function put(url, data, config) {
    return new Promise((resolve, reject) => {
        NetworkService.put(url, data, config)
            .then((data) => {
            resolve(data);
        })
            .catch((error) => {
            reject(makeUFSErrorFromReactError(error));
        });
    });
}
/**
 * Отличие `syncGet` от `get` состоит в том, что запросы от метода `syncGet` направляются в единую очередь запросов.
 * Единая очередь гарантирует их строгое и последовательное выполнение, то есть запрос,
 * "В", поступивший после запроса "А", начнёт своё исполнение после получения ответа на запрос "А".
 * При возникновении ошибки в запросе "А" вызывается блок для обработки ошибок, и очередь переходит к обработке запроса "В".
 *
 * **Входные параметры:**
 * - `url` - адрес сервера;
 * - `config` - конфигурация сетевого запроса.
 *
 * **Возвращаемые значения:**
 * - Promise - JS-объект типа Promise с состояниями:
 *   - `resolve(data: Object)` - операция завершена успешно. В блок `resolve` передаются данные, полученные от сервера.
 *   - `rejected(error: UFSError)` - операция завершилась неудачно. Возможные коды ошибок:
 *     - Вложенный `NSError`
 * @category Nonvisual/Network
 */
export function syncGet(url, config) {
    return new Promise((resolve, reject) => {
        NetworkService.syncGet(url, config)
            .then((data) => {
            resolve(data);
        })
            .catch((error) => {
            reject(makeUFSErrorFromReactError(error));
        });
    });
}
/**
 * Отличие `syncPost` от `post` состоит в том, что запросы от метода `syncPost` направляются в единую очередь запросов.
 * Единая очередь гарантирует их строгое и последовательное выполнение, то есть запрос,
 * "В", поступивший после запроса "А", начнёт своё исполнение после получения ответа на запрос "А".
 * При возникновении ошибки в запросе "А" вызывается блок для обработки ошибок, и очередь переходит к обработке запроса "В".
 *
 * **Входные параметры:**
 * - `url` - адрес сервера;
 * - `data` - тело запроса;
 * - `config` - конфигурация сетевого запроса.
 *
 * **Возвращаемые значения:**
 * - Promise - JS-объект типа Promise с состояниями:
 *   - `resolve(data: Object)` - операция завершена успешно. В блок `resolve` передаются данные, полученные от сервера.
 *   - `rejected(error: UFSError)` - операция завершилась неудачно. Возможные коды ошибок:
 *     - `UFSNetworkServiceErrorCodeInvalidJSON`
 *     - Вложенный `NSError`
 * @category Nonvisual/Network
 */
export function syncPost(url, data, config) {
    return new Promise((resolve, reject) => {
        NetworkService.syncPost(url, data, config)
            .then((data) => {
            resolve(data);
        })
            .catch((error) => {
            reject(makeUFSErrorFromReactError(error));
        });
    });
}
/**
 * Отличие `syncPut` от `put` от состоит в том, что запросы от метода `syncPut` направляются в единую очередь запросов.
 * Единая очередь гарантирует их строгое и последовательное выполнение, то есть запрос,
 * "В", поступивший после запроса "А", начнёт своё исполнение после получения ответа на запрос "А".
 * При возникновении ошибки в запросе "А" вызывается блок для обработки ошибок, и очередь переходит к обработке запроса "В".
 *
 * **Входные параметры:**
 * - `url` - адрес сервера;
 * - `data` - тело запроса;
 * - `config` - конфигурация сетевого запроса.
 *
 * **Возвращаемые значения:**
 * - Promise - JS-объект типа Promise с состояниями:
 *   - `resolve(data: Object)` - операция завершена успешно. В блок `resolve` передаются данные, полученные от сервера.
 *   - `rejected(error: UFSError)` - операция завершилась неудачно. Возможные коды ошибок:
 *     - `UFSNetworkServiceErrorCodeInvalidJSON`
 *     - Вложенный `NSError`
 * @category Nonvisual/Network
 */
export function syncPut(url, data, config) {
    return new Promise((resolve, reject) => {
        NetworkService.syncPut(url, data, config)
            .then((data) => {
            resolve(data);
        })
            .catch((error) => {
            reject(makeUFSErrorFromReactError(error));
        });
    });
}
//# sourceMappingURL=UFSNetworkService.js.map