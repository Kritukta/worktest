import { NativeModules } from 'react-native';
import * as actions from '../../../../JSCore/Actions//UFSWorkflowActionCreators';
import { WorkflowStatus } from '../../../../JSCore/Common/UFSInterfaces';
import { makeUFSErrorFromReactError, makeWorkflowErrorWithReactError } from '../../../../JSCore/Common/UFSError';
import { DataBus } from '../../DataBus';
var Workflow = NativeModules.UFSWorkflowBridge;
var store;
/**
 * Компонент служит для управления навигацией внутри процесса, состоящего из этапов.
 * Компонент имеет свой раздел в redux store приложения.
 * В одном приложении существует только один раздел в redux store.
 * Для визуального отображения состояния `Workflow` используется компонент `WFBreadcrumbs` (Автоматические хлебные крошки),
 * который автоматически отображает текущее состояние `Workflow`.
 *
 * Для отображения также используется визуальный компонент `Breadcrumbs` (Хлебные крошки).
 *
 * См. также описание `Workflow` на странице документации Ядра Платформы ЕФС
 * [документации Ядра Платформы ЕФС](http://sbt-orefs-063.sigma.sbrf.ru/java/ufs-platform-doc/6.7.0/4_platformModules/5_workflow/workflow.html)
 *
 * ##### Обратите внимание
 * + Для корректной работы в прикладном приложении должен использоваться библиотечный `UFSProvider`.
 * + В одном приложении существует только один раздел в redux store.
 *
 * ##### Workflow state
 * Одна из секций redux store state посвящена Workflow. В ней находится вся актуальная информация по текущему процессу:
 *
 * | Свойство          | Тип             | Описание  |
 * | ----------------- | --------------- | --------- |
 * | workflowError     | `WorkflowError` | Ошибка в формате `WorkflowError` (подробная ошибка от сервера workflow); |
 * | url               | `string`        | URL текущего процесса; |
 * | status            | `WorkflowStatus.SUCCESS` `WorkflowStatus.EXTERNAL_ENTER` `WorkflowStatus.EXTERNAL_RETURN` `WorkflowStatus.END` | Текущий статус состояния процесса; |
 * | stateName         | `string`        | Имя текущего шага; |
 * | processId         | `string`        | Идентификатор процесса; |
 * | isLoading         | `boolean`       | Выставляется в `true` каждый раз, когда модуль обращается на сервер за обновлённым состоянием; |
 * | history           | `Object[]`      | Информация о пройденных шагах процесса; |
 * | hintSwitchEnabled | `boolean`       | Флаг, на основании которого определяется доступность компонента "переключатель подсказок" для пользователя; |
 * | hintsVisible      | `boolean`       | Флаг, на основании которого определяется видимость подсказок для пользователя; |
 * | hints             | `Object`        | Объект содержит информацию о пользовательских подсказках для текущего шага процесса. Данные приходят с сервера; |
 * | flowName          | `string`        | Имя текущего flow; |
 * | error             | `UFSError`      | Ошибка в формате `UFSError`; |
 * | data              | `Object`        | Данные формы, возвращённые сервером. |
 * @category Nonvisual
 */
export default class UFSWorkflow {
    /**
     * Техническая функция. Не должна экспортироваться. Экспортирование оставлено для обратной совместимости.
     * @private
     * @static
     */
    static setStore(applicationStore) {
        store = applicationStore;
    }
    static getStore() {
        return store;
    }
    /**
     * Перед первым использованием любого из методов компонента следует задать базовый URL. См. пример:
     * ```
     * Workflow.setBaseUrl('http://sbt-orefs-063.sigma.sbrf.ru');
     * ```
     *
     * **Входные параметры:**
     * - `baseUrl` - базовый URL.
     * @static
     */
    static setBaseUrl(baseUrl) {
        Workflow.setBaseUrl(baseUrl);
    }
    /**
     * Инициализирует workflow-процесс с указанными настройками.
     *
     * Чтобы инициализировать новый workflow-процесс во время работы пользователя с приложением,
     * необходимо предварительно завершить предыдущий.
     * Завершение процесса должно быть частью общей логики и вызываться через стандартные методы работы с `Workflow`.
     * Завершение произойдёт, когда сервер вернёт статус `WorkflowStatus.END`.
     * Этот статус будет записан в `Workflow.State`.
     * После завершения процесса можно вызывать `initFlow`.
     * При этом `proccessId` останется прежним, а другие параметры отчистятся.
     *
     * **Входные параметры:**
     * - `options` - настройки процесса, состоящие из двух обязательных значений:
     *   - `url` - начальный url для запросов;
     *   - `flowName` - название flow;
     * - `data` - начальные POST-данные.
     * @static
     */
    static initFlow(options, data = {}) {
        store.dispatch(actions.init(options));
        const { processId, status } = store.getState().workflow;
        const url = options.url;
        const flowName = options.flowName;
        if (processId && (status === WorkflowStatus.EXTERNAL_ENTER || status === WorkflowStatus.EXTERNAL_RETURN)) {
            UFSWorkflow.sendStateEvent(status === WorkflowStatus.EXTERNAL_RETURN ? 'on-return' : 'on-enter', data);
        }
        else {
            const dataString = JSON.stringify(data);
            store.dispatch(actions.sendCommand());
            Workflow.initFlow(flowName, url, dataString)
                .then((response) => {
                store.dispatch(actions.success(response.body));
                UFSWorkflow.sendProcessIdToContainer(response.body);
                UFSWorkflow.sendStatusToContainer(response.body);
            })
                .catch((error) => {
                const ufsError = makeUFSErrorFromReactError(error);
                const workflowError = makeWorkflowErrorWithReactError(error);
                store.dispatch(actions.error(ufsError, workflowError));
            });
        }
    }
    /**
     * Отправляет событие для текущего состояния.
     * Функция не должна вызываться из прикладного кода,
     * используется только самим компонентом `Workflow`.
     * @static
     * @private
     */
    static sendStateEvent(eventName, data = {}) {
        const state = store.getState();
        const processId = state.workflow.processId;
        const url = state.workflow.url;
        const dataString = JSON.stringify(data);
        store.dispatch(actions.sendCommand());
        Workflow.sendStateEvent(eventName, url, processId, dataString)
            .then((response) => {
            store.dispatch(actions.success(response.body));
            UFSWorkflow.sendStatusToContainer(response.body);
        })
            .catch((error) => {
            const ufsError = makeUFSErrorFromReactError(error);
            const workflowError = makeWorkflowErrorWithReactError(error);
            store.dispatch(actions.error(ufsError, workflowError));
        });
    }
    /**
     * Отправляет команду восстановления предыдущего шага истории.
     *
     * **Входные параметры:**
     * - `stateId` - идентификатор шага истории. Доступен по ключу `id` у каждого элемента `state.workflow.history`.
     * @static
     */
    static rollbackState(stateId) {
        const state = store.getState();
        const processId = state.workflow.processId;
        const url = state.workflow.url;
        store.dispatch(actions.sendCommand());
        Workflow.rollbackState(stateId, url, processId)
            .then((response) => {
            store.dispatch(actions.success(response.body));
            UFSWorkflow.sendStatusToContainer(response.body);
        })
            .catch((error) => {
            const ufsError = makeUFSErrorFromReactError(error);
            const workflowError = makeWorkflowErrorWithReactError(error);
            store.dispatch(actions.error(ufsError, workflowError));
        });
    }
    /**
     * Отправляет команду выхода из flow.
     *
     * **Входные параметры:**
     * отсутствуют
     * @static
     */
    static exitFlow() {
        const state = store.getState();
        const processId = state.workflow.processId;
        const url = state.workflow.url;
        store.dispatch(actions.sendCommand());
        Workflow.exitFlow(url, processId)
            .then((response) => {
            store.dispatch(actions.success(response.body));
            UFSWorkflow.sendStatusToContainer(response.body);
        })
            .catch((error) => {
            const ufsError = makeUFSErrorFromReactError(error);
            const workflowError = makeWorkflowErrorWithReactError(error);
            store.dispatch(actions.error(ufsError, workflowError));
        });
    }
    /**
     * Отправляет команду прерывания процесса.
     *
     * **Входные параметры:**
     * отсутствуют
     * @static
     */
    static abortProcess() {
        const state = store.getState();
        const processId = state.workflow.processId;
        const url = state.workflow.url;
        store.dispatch(actions.sendCommand());
        Workflow.abortProcess(url, processId)
            .then((response) => {
            store.dispatch(actions.success(response.body));
            UFSWorkflow.sendStatusToContainer(response.body);
        })
            .catch((error) => {
            const ufsError = makeUFSErrorFromReactError(error);
            const workflowError = makeWorkflowErrorWithReactError(error);
            store.dispatch(actions.error(ufsError, workflowError));
        });
    }
    /**
     * Сообщает обновленные данные для текущего состояния перед их отправкой с помощью `sendStateEvent`.
     *
     * **Входные параметры:**
     * - `data` - обновлённые данные.
     * @static
     */
    static updateStateData(data) {
        store.dispatch(actions.updateStateDataAction(data));
    }
    /**
     * Отправляет событие для текущего состояния с данными установленными ранее с помощью функции `updateStateData`.
     *
     * **Входные параметры:**
     * - `eventName` - имя события.
     * @private
     * @static
     */
    static submitStateEvent(eventName) {
        const state = store.getState();
        UFSWorkflow.sendStateEvent(eventName, state.workflow.data);
    }
    /**
     * Меняет доступность компонента `HintSwitch`.
     *
     * **Входные параметры:**
     * - `enabling` - флаг, определяющий доступность для нажатия компонента `HintSwitch`.
     * @static
     */
    static updateHintSwitchEnabling(enabling) {
        store.dispatch(actions.updateHintSwitchEnabling(enabling));
    }
    /**
     * Меняет видимость подсказок для пользователя.
     *
     * **Входные параметры:**
     * - `visible` - флаг, определяющий видимость подсказок для пользователя.
     * @static
     */
    static updateHintsVisibility(visible) {
        store.dispatch(actions.updateHintsVisibility(visible));
    }
    static sendStatusToContainer(workflowData) {
        DataBus.sendMessage({
            type: 'WF_' + workflowData.result
        }, 'active-operation-container')
            .catch(error => { });
    }
    static sendProcessIdToContainer(workflowData) {
        DataBus.sendMessage({
            type: 'WF_PID',
            pid: workflowData.pid
        }, 'active-operation-container')
            .catch(error => { });
    }
}
//# sourceMappingURL=UFSWorkflow.js.map