/// <reference types="react-native" />
/// <reference types="react" />
import React, { Component, ReactNode } from 'react';
import { ViewStyle } from 'react-native';
import { Coordinate } from '../../../../JSCore/Common/UFSInterfaces';
import { UFSError, ErrorUserInfo } from '../../../../JSCore/Common/UFSError';
export declare const UFSMapSource: any;
export declare const UFSRouteType: any;
export interface ChangeEvent {
    nativeEvent: {
        center: Coordinate;
        zoom: number;
    };
}
export interface OnMapErrorEvent {
    nativeEvent: {
        error: ErrorUserInfo;
    };
}
/**
 *  + `duration` - Время проезда маршрута в секундах. В случае `traffic == true` время указывается с учётом пробок;
 *  + `distance` - Протяженность маршрута в метрах.
 */
export interface Route {
    duration: number;
    distance: number;
}
export interface onMakeRouteEvent {
    nativeEvent: {
        routes: Route[];
    };
}
export interface OnChangeActiveRoute {
    nativeEvent: {
        activeRouteIndex: number;
    };
}
export interface Props extends React.Props<UFSMapManager> {
    /**
     * Тип карты из словаря MapSource. Доступные значения:
     * - `Yandex` - яндекс карта(значение умолчанию).
     */
    source?: number;
    /**
     * API ключ карты. По умолчанию используется карта без API ключа и у нее имеются ограничение на использование геокодера.
     *
     * Является опциональным свойством, но по лицензии Яндекса API ключ обязателен.
     */
    apiKey?: string;
    /**
     * Определяет показывать пробки или нет. Свойство влияет на построение маршрутов, подробнее в описании свойства `route`.
     * По умолчанию `false`.
     */
    traffic?: boolean;
    /**
     * Определяет показывать местоположение пользователя или нет.
     *
     * При значении `true` местоположение всегда будет автоматически обновляться, что приведет к повышенному энергопотреблению.
     * По умолчанию `false`.
     */
    userLocation?: boolean;
    /**
     * Уровень зума карты.
     * Зум автоматически обрезается до интервала [0, 23]. Уровень может быть не целым числом.
     * По умолчанию 5.
     */
    zoom?: number;
    /**
     * Координата центра карты.
     * По умолчанию координата центра равна 55.76, 37.64 (центр Москвы).
     */
    center?: Coordinate;
    /**
     * Точки маршрута.
     * В качестве точек могут использоваться следующие объекты:
     * 1. географическая координата;
     * 2. идентификатор маркера;
     * 3. адрес в виде строки - в этом случае будет использован геокодер яндекса.
     *
     * При использовании идентификатора маркера маршрут привязывается к маркеру и при обновлении координаты маркера маршурт также будет
     * автоматически обновляться. Если указать несуществующий идентификатор, то маршрут построен не будет.
     *
     * В массиве должны находиться как минимум 2 точек: начальная и конечная точки.
     * При этом можно указать больше точек - все точки, кроме начальной и конечной, будут транзитными.
     * На карте могут отображаться только маршруты, построенные по одному набору точек.
     *
     * Маршруты строятся с учётом пробок в случае `traffic == true` и без учёта пробок в случае `traffic == false`.
     */
    route?: Array<Coordinate | MapAddress | MapMarkerId>;
    /**
     * Тип маршрута из словаря RouteType. Доступные значения:
     * - `Car` - маршрут на машине (значение по умолчанию);
     * - `PublicTransport` - маршрут на общественном транспорте.
     */
    routeType?: number;
    /**
     * Стили React.
     */
    style?: ViewStyle;
    /**
     * Идентификатор для UI-тестирования.
     */
    testID?: string;
    /**
     * Дочерние компоненты могут быть следующих типов:
     * - `MapContent`;
     * - `MapControls`.
     */
    children?: ReactNode;
}
export interface PublicProps extends Props {
    /**
     * Вызывается при изменении центра карты или уровня зума.
     */
    onChange?: (coordinate: Coordinate, zoom?: number) => void;
    /**
     * Вызывается при ошибке загрузки карты (когда задан неправильный либо устаревший `apiKey`) или при ошибке в построении маршрута.
     */
    onError?: (error: UFSError) => void;
    /**
     * Вызывается при успешном построении маршрута. В качестве параметра передается массив с различными вариантами маршрутов, но не менее одного.
     */
    onMakeRoute?: (routes: Route[]) => void;
    /**
     * Вызывается при смене активного маршрута.
     */
    onChangeActiveRoute?: (activeRouteIndex: number) => void;
}
export interface PrivateProps extends Props {
    onChange?: (event: ChangeEvent) => void;
    onError?: (event: OnMapErrorEvent) => void;
    onMakeRoute?: (event: onMakeRouteEvent) => void;
    onChangeActiveRoute?: (event: OnChangeActiveRoute) => void;
}
export interface MapAddress {
    /**
     * Адрес.
     */
    address: string;
}
export interface MapMarkerId {
    /**
     * Уникальный идентификатор маркера.
     */
    markerId: string;
}
/**
 * Используется для отображения карты.
 * На карте могут отображаться местоположение пользователя, пробки, а также маршруты.
 *
 * ##### Особенности
 * Для использования `userLocation` необходимо модифицировать настройки проекта:
 * надо добавить флаг `NSLocationWhenInUseUsageDescription` в файл Info.plist и задать ему значение (н. "Локация используется для отображения местороложения на карте").
 *
 * ##### Геокодирование
 * Геокодер яндекса используется при использовании адреса в качестве точки маршрута, либо при использовании адреса в качестве локации маркера.
 * Результаты геокодирования кэшируется на время жизни приложения. При нехватке оперативной памяти этот кэш может быть автоматически очищен.
 * Также кэш может быть принудительно очищен с помощью сервиса `GeocoderService`.
 * @category Visual/Map
 */
export default class UFSMapManager extends Component<PublicProps, {}> {
    static defaultProps: {
        apiKey: string;
        center: {
            lat: number;
            lng: number;
        };
    };
    private mapContent;
    private mapControls;
    private trafficButton;
    componentWillMount(): void;
    componentWillReceiveProps(nextProps: Props): void;
    onChange: (event: ChangeEvent) => void;
    onError: (event: OnMapErrorEvent) => void;
    onMakeRoute: (event: onMakeRouteEvent) => void;
    onChangeActiveRoute: (event: OnChangeActiveRoute) => void;
    handlePropsUpdate: (props: Props) => void;
    traverseMapControls: (mapControls: React.ReactChildren) => void;
    render(): JSX.Element;
}
