/// <reference types="react" />
/// <reference types="react-native" />
import React, { Component, ReactNode } from 'react';
import { ViewStyle } from 'react-native';
export interface Props extends React.Props<UFSPageManager> {
    /**
     * @private
     * Определяет имеются ли предыдущие страницы у родительского контейнера.
     */
    hasPrev?: boolean;
    /**
     * @private
     * Определяет показывать ли кнопку назад автоматически.
     */
    showAutoBackButton?: boolean;
    /**
     * @private
     * Фоновый цвет навигационного бара.
     */
    barColor?: string;
    /**
     * @private
     * Вызывается при клике на автоматическую кнопку назад.
     */
    onBackButtonClick?: () => void;
    /**
     * @private
     * Определяет надо ли показывать нижнюю границу у навигационного бара.
     */
    showBorder?: boolean;
    /**
     * Включает/отключает возможность скрола для страницы.
     *
     * По умолчанию `true`.
     */
    scrollEnabled?: boolean;
    /**
     * Дочерние компоненты могут быть следующих типов:
     * - `LeftPageHeader`
     * - `CenterPageHeader`
     * - `RightPageHeader`
     * - `PageContent`
     * - `PageFooter`
     */
    children?: ReactNode;
    /**
     * @private
     * Стили React.
     */
    style?: ViewStyle;
    /**
     * JSX-контент, который будет отображаться на данной странице.
     *
     * Для корректной работы у корневой view должно отсутствовать flex-свойство.
     *
     * В качестве альтернативы этому свойству можно использовать компонент `PageContent`, добавляя `PageContent` как children `Page`.
     * Поведение при использовании `PageContent` останется аналогичным свойству `content`, при этом `PageContent` имеет приоритет над свойством `content`.
     */
    content?: JSX.Element;
    /**
     * JSX-контент, который будет отображаться внизу данной страницы и не попадает в скроллируемую область.
     * Мы не накладываем каких либо своих стилей на этот контент и его внешний вид и высота задаются в прикладном приложении.
     *
     * Поскольку данный элемент всегда отрисовывается снизу строки и не скроллится,
     * мы не можем в нем обеспечить работу компонентов ввода (`TextInput`, `NumberInput` и т.д.)
     * поскольку они окажутся под экранной клавиатурой. Также мы не гарантируем работоспособность внутри компонента Popover.
     *
     * В качестве альтернативы этому свойству можно использовать компонент `PageFooter`, добавляя `PageFooter` как children `Page`.
     * Поведение при использовании `PageFooter` останется аналогичным свойству `footer`, при этом `PageFooter` имеет приоритет над свойством `footer`.
     */
    footer?: JSX.Element;
    /**
     * Идентификатор для UI-тестирования.
     */
    testID?: string;
}
/**
 * Используется для логического разбиения содержимого на странице.
 *
 * <br/>
 *
 * Состоит из навигационного бара и области контента.
 *
 * ##### Навигационный бар
 * Навигационный бар делится на 3 области и конфигурируется с помощью дочерних компонентов `LeftPageHeader`, `CenterPageHeader`, `RightPageHeader`.
 * На уровне библиотеки пересечение областей не блокируется -
 * корректное отображение должно задаваться на уровне прикладного кода в соответствии с целевым дизайном.
 *
 * <br/>
 *
 * При отстуствии дочерних компонентов `LeftPageHeader`, `CenterPageHeader` или `RightPageHeader` область навигационного бара освобожается и не занимает место.
 * Стоит иметь в виду, что дочерний компонент `LeftPageHeader` может появиться автоматически,
 * если у родительского контейнера(`ContentPanel` или `AccessoryPanel`) задано свойство `showAutoBackButton`.
 *
 * ##### Методы
 * 1. scrollTo(y: number, animated: boolean)
 *
 * <br/>
 *
 * Прокручивает содержимое страницы к заданному значению вертикальной координаты.
 * 2. scrollToEnd(animated: boolean)
 *
 * * <br/>
 *
 * Прокручивает содержимое страницы в самый низ.
 * @category Visual/SplitPanel
 */
export default class UFSPageManager extends Component<Props, {}> {
    private leftPageContent;
    private centerPageContent;
    private rightPageContent;
    private pageContent;
    private pageFooter;
    private scrollViewRef;
    componentWillMount(): void;
    onScrollViewRef: (ref: any) => void;
    /**
     * Прокручивает содержимое страницы к заданному значению вертикальной координаты.
     */
    scrollTo(y: number, animated: boolean): void;
    /**
     * Прокручивает содержимое страницы в самый низ.
     */
    scrollToEnd(animated: Boolean): void;
    componentWillReceiveProps(nextProps: Object): void;
    handlePropsUpdate: (props: Props) => void;
    renderHeaderContent: () => JSX.Element;
    private renderContent;
    private renderFooter;
    render(): JSX.Element;
}
export declare class UFSPageContent extends Component<{}, {}> {
    render(): JSX.Element;
}
export declare class UFSPageFooter extends Component<{}, {}> {
    render(): JSX.Element;
}
