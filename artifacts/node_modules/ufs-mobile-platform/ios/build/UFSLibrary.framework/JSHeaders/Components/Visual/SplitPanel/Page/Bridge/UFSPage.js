import React, { Component } from 'react';
import { requireNativeComponent, ScrollView, StyleSheet } from 'react-native';
import UFSNavigationBar from '../../NavigationBar/Bridge/UFSNavigationBar';
import UFSNavigationBackButton from '../../NavigationBackButton/Bridge/UFSNavigationBackButton';
import UFSLeftPageHeader from '../../LeftPageHeader/Bridge/UFSLeftPageHeader';
import UFSCenterPageHeader from '../../CenterPageHeader/Bridge/UFSCenterPageHeader';
import UFSRightPageHeader from '../../RightPageHeader/Bridge/UFSRightPageHeader';
/**
 * Используется для логического разбиения содержимого на странице.
 *
 * <br/>
 *
 * Состоит из навигационного бара и области контента.
 *
 * ##### Навигационный бар
 * Навигационный бар делится на 3 области и конфигурируется с помощью дочерних компонентов `LeftPageHeader`, `CenterPageHeader`, `RightPageHeader`.
 * На уровне библиотеки пересечение областей не блокируется -
 * корректное отображение должно задаваться на уровне прикладного кода в соответствии с целевым дизайном.
 *
 * <br/>
 *
 * При отстуствии дочерних компонентов `LeftPageHeader`, `CenterPageHeader` или `RightPageHeader` область навигационного бара освобожается и не занимает место.
 * Стоит иметь в виду, что дочерний компонент `LeftPageHeader` может появиться автоматически,
 * если у родительского контейнера(`ContentPanel` или `AccessoryPanel`) задано свойство `showAutoBackButton`.
 *
 * ##### Методы
 * 1. scrollTo(y: number, animated: boolean)
 *
 * <br/>
 *
 * Прокручивает содержимое страницы к заданному значению вертикальной координаты.
 * 2. scrollToEnd(animated: boolean)
 *
 * * <br/>
 *
 * Прокручивает содержимое страницы в самый низ.
 * @category Visual/SplitPanel
 */
export default class UFSPageManager extends Component {
    constructor() {
        super(...arguments);
        this.scrollViewRef = null;
        this.onScrollViewRef = (ref) => {
            this.scrollViewRef = ref;
        };
        this.handlePropsUpdate = (props) => {
            this.leftPageContent = null;
            this.centerPageContent = null;
            this.rightPageContent = null;
            this.pageContent = null;
            this.pageFooter = null;
            React.Children.map(props.children, (child) => {
                if (child) {
                    if (child.type === UFSLeftPageHeader) {
                        this.leftPageContent = child;
                    }
                    else if (child.type === UFSCenterPageHeader) {
                        this.centerPageContent = child;
                    }
                    else if (child.type === UFSRightPageHeader) {
                        this.rightPageContent = child;
                    }
                    else if (child.type === UFSPageContent) {
                        this.pageContent = child;
                    }
                    else if (child.type === UFSPageFooter) {
                        this.pageFooter = child;
                    }
                    return child;
                }
            });
            if (!this.leftPageContent && props.showAutoBackButton && props.hasPrev) {
                this.leftPageContent = (React.createElement(UFSLeftPageHeader, null, 
                    React.createElement(UFSNavigationBackButton, {title: "Назад", onClick: props.onBackButtonClick})
                ));
            }
        };
        this.renderHeaderContent = () => {
            const isNavigationBarEmpty = !(this.leftPageContent || this.centerPageContent || this.rightPageContent);
            if (isNavigationBarEmpty) {
                return null;
            }
            return (React.createElement(UFSNavigationBar, {backgroundColor: this.props.barColor, showBorder: this.props.showBorder}, 
                this.leftPageContent || React.createElement(UFSLeftPageHeader, null), 
                this.centerPageContent || React.createElement(UFSCenterPageHeader, null), 
                this.rightPageContent || React.createElement(UFSRightPageHeader, null)));
        };
        this.renderContent = () => {
            return this.pageContent ? this.pageContent.props.children : this.props.content;
        };
        this.renderFooter = () => {
            return this.pageFooter ? this.pageFooter.props.children : this.props.footer;
        };
    }
    componentWillMount() {
        this.handlePropsUpdate(this.props);
    }
    /**
     * Прокручивает содержимое страницы к заданному значению вертикальной координаты.
     */
    scrollTo(y, animated) {
        this.scrollViewRef.scrollTo({ y, x: 0, animated });
    }
    /**
     * Прокручивает содержимое страницы в самый низ.
     */
    scrollToEnd(animated) {
        this.scrollViewRef.scrollToEnd({ animated });
    }
    componentWillReceiveProps(nextProps) {
        this.handlePropsUpdate(nextProps);
    }
    render() {
        return (React.createElement(UFSPageView, {style: styles.container, scrollEnabled: this.props.scrollEnabled, testID: this.props.testID}, 
            this.renderHeaderContent(), 
            React.createElement(ScrollView, {ref: this.onScrollViewRef, style: styles.container, contentContainerStyle: styles.scrollContainer}, this.renderContent()), 
            this.renderFooter()));
    }
}
export class UFSPageContent extends Component {
    render() {
        return null;
    }
}
export class UFSPageFooter extends Component {
    render() {
        return null;
    }
}
const styles = StyleSheet.create({
    container: {
        flex: 1
    },
    scrollContainer: {
        flexGrow: 1
    }
});
const UFSPageView = requireNativeComponent('UFSPageView');
//# sourceMappingURL=UFSPage.js.map