/// <reference types="react-native" />
/// <reference types="react" />
import React, { Component, ComponentProvider } from 'react';
import { Animated, ViewStyle, LayoutRectangle, LayoutChangeEvent, ReactNode } from 'react-native';
export declare type TransitionAnimation = (animatedValue: Animated.Value, layout: LayoutRectangle) => ViewStyle;
export interface TransitionAnimationConfig {
    hiding: TransitionAnimation;
    appearing: TransitionAnimation;
    easing: React.EasingFunction;
    duration: number;
}
export interface Props {
    /**
     * Функция, которая возвращает класс компонента, который должен быть отображён. Сам компонент будет создан автоматически.
     */
    content: ComponentProvider;
    /**
     * Объект который описывает анимацию. Содержит четыре поля:
     * - `duration` описывает время анимации в миллисекундах, в случае не положительного значения, переход осуществляется без анимации;
     * - `easing` - объект типа `React.EasingFunction`;
     * - `hiding` и `appearing` - функции, возвращающие анимированные стили, для применения к старому и новому компонентам соответственно.
     *
     * Встроенные типы анимаций находятся в объекте `TransitionAnimationConfigPresets`. Доступны `push`, `pop`, `fadeInFadeOut` и `none`.
     */
    animation?: TransitionAnimationConfig;
    /**
     * Объект, который содержит свойтсва компонента, которые будут переданы ему при создании. Обратите внимание, что свойства
     * являются неизменяемыми и компоненты одного класса с разными свойствами являются разными компонентами, поэтому между
     * ними возможен переход.
     */
    properties?: any;
    /**
     * коллбэк, который будет вызван при начале анимации.
     */
    onAnimationStart?: () => void;
    /**
     * коллбэк, который будет вызван при окончании анимации.
     */
    onAnimationFinish?: () => void;
    /**
     * коллбэк, который будет вызван при начале перехода.
     */
    onTransitionStart?: () => void;
    /**
     * коллбэк, который будет вызван при окончании перехода.
     */
    onTransitionFinish?: () => void;
    /**
     * @private
     */
    children?: ReactNode;
}
export interface State {
    animationIsInProgress: boolean;
}
/**
 * Компонент представляет из себя контейнер, который позволяет осуществлять анимированную замену одного компонента другим (Transition).
 * Компонент поддерживает коллбэки старта (`onAnimationStart`) и конца (`onAnimationFinish`) анимации. Обратите внимание, что коллбэки анимации
 * запускаются только в случае фактических начала и завершения анимации. коллбэки переходов `onTransitionStart` и `onTransitionFinish`,
 * в отличии от коллбэков анимации, будут вызваны перед началом и после окончания перехода вне зависимости от типа анимации. Переход
 * будет осуществлён сразу, при появлении нового компонента. Первичная отрисовка происходит без анимации.
 *
 * В рамках `TransitionContainer` компоненты считаются разными, если они имеют разный класс или разные свойства. Например, изменение
 * свойства `content` не вызовет анимированного перехода, если эта функция возвратит класс компонента, совпадающий с текущим.
 *
 * Обратите внимание, что запущенная анимация не может быть прервана. В случае обновления компонента во время анимации, которое должно
 * инициировать переход, анимация продолжится, при этом _появляющийся_ компонент будет без анимации заменён на новый.
 *
 * @category Visual/Workspace
 */
export default class UFSTransitionContainer extends Component<Props, State> {
    state: State;
    private newContent?;
    private properites?;
    private oldContent?;
    private finishAnimationCallback;
    private finishCallbacks?;
    private animation?;
    private transitionAnimation;
    private layoutRectangle;
    constructor(props: Props);
    onLayout: (event: LayoutChangeEvent) => void;
    shouldComponentUpdate(nextProps: Props, nextState: State): boolean;
    componentWillUpdate(nextProps: Props, nextState: State): void;
    private renderContent();
    render(): JSX.Element;
}
export declare const TransitionAnimationConfigPresets: {
    push: {
        duration: number;
        easing: React.EasingFunction;
        hiding: (animatedValue: Animated.Value, layout: LayoutRectangle) => ViewStyle;
        appearing: (animatedValue: Animated.Value, layout: LayoutRectangle) => ViewStyle;
    };
    pop: {
        duration: number;
        easing: React.EasingFunction;
        hiding: (animatedValue: Animated.Value, layout: LayoutRectangle) => ViewStyle;
        appearing: (animatedValue: Animated.Value, layout: LayoutRectangle) => ViewStyle;
    };
    none: {
        duration: number;
        easing: React.EasingFunction;
        hiding: (animatedValue: Animated.Value, layout: LayoutRectangle) => ViewStyle;
        appearing: (animatedValue: Animated.Value, layout: LayoutRectangle) => ViewStyle;
    };
    fadeInFadeOut: {
        duration: number;
        easing: React.EasingFunction;
        hiding: (animatedValue: Animated.Value, layout: LayoutRectangle) => ViewStyle;
        appearing: (animatedValue: Animated.Value, layout: LayoutRectangle) => ViewStyle;
    };
};
