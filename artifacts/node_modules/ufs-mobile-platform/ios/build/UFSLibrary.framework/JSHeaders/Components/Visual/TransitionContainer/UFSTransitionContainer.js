import React, { Component } from 'react';
import { Animated, View, Easing } from 'react-native';
/**
 * Компонент представляет из себя контейнер, который позволяет осуществлять анимированную замену одного компонента другим (Transition).
 * Компонент поддерживает коллбэки старта (`onAnimationStart`) и конца (`onAnimationFinish`) анимации. Обратите внимание, что коллбэки анимации
 * запускаются только в случае фактических начала и завершения анимации. коллбэки переходов `onTransitionStart` и `onTransitionFinish`,
 * в отличии от коллбэков анимации, будут вызваны перед началом и после окончания перехода вне зависимости от типа анимации. Переход
 * будет осуществлён сразу, при появлении нового компонента. Первичная отрисовка происходит без анимации.
 *
 * В рамках `TransitionContainer` компоненты считаются разными, если они имеют разный класс или разные свойства. Например, изменение
 * свойства `content` не вызовет анимированного перехода, если эта функция возвратит класс компонента, совпадающий с текущим.
 *
 * Обратите внимание, что запущенная анимация не может быть прервана. В случае обновления компонента во время анимации, которое должно
 * инициировать переход, анимация продолжится, при этом _появляющийся_ компонент будет без анимации заменён на новый.
 *
 * @category Visual/Workspace
 */
export default class UFSTransitionContainer extends Component {
    constructor(props) {
        super(props);
        this.state = {
            animationIsInProgress: false
        };
        this.finishCallbacks = [];
        this.layoutRectangle = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
        };
        this.onLayout = (event) => {
            this.layoutRectangle = event.nativeEvent.layout;
        };
        this.properites = this.props.properties ? this.props.properties : {};
        this.newContent = React.createElement(this.props.content(), this.properites);
    }
    shouldComponentUpdate(nextProps, nextState) {
        const prevContentProvider = this.props.content();
        const nextContentProvider = nextProps.content();
        const contentDidChange = prevContentProvider !== nextContentProvider;
        const prevContentProps = this.props.properties;
        const nextContentProps = nextProps.properties;
        const contentPropsDidChange = prevContentProps !== nextContentProps;
        const prevAnimationState = this.state.animationIsInProgress;
        const nextAnimationState = nextState.animationIsInProgress;
        const animationStateDidChange = prevAnimationState !== nextAnimationState;
        return contentDidChange || contentPropsDidChange || animationStateDidChange;
    }
    componentWillUpdate(nextProps, nextState) {
        if (this.state.animationIsInProgress) {
            if (this.props.content() != nextProps.content()) {
                nextProps.onTransitionStart && nextProps.onTransitionStart();
                nextProps.onTransitionFinish && this.finishCallbacks.push(nextProps.onTransitionFinish);
                this.newContent = React.createElement(nextProps.content(), nextProps.properties);
            }
            return;
        }
        nextProps.onTransitionStart && nextProps.onTransitionStart();
        nextProps.onTransitionFinish && this.finishCallbacks.push(nextProps.onTransitionFinish);
        this.transitionAnimation = nextProps.animation ? nextProps.animation : TransitionAnimationConfigPresets.none;
        this.oldContent = this.newContent;
        this.newContent = React.createElement(nextProps.content(), nextProps.properties);
        const animationIsInProgress = true;
        this.animation = new Animated.Value(0);
        const duration = this.transitionAnimation.duration;
        const easing = this.transitionAnimation.easing;
        if (this.transitionAnimation.duration <= 0) {
            this.oldContent = null;
            nextProps.onTransitionFinish && nextProps.onTransitionFinish();
        }
        else {
            this.state.animationIsInProgress = animationIsInProgress;
            nextProps.onAnimationStart && nextProps.onAnimationStart();
            if (nextProps.onAnimationFinish) {
                this.finishAnimationCallback = nextProps.onAnimationFinish;
            }
            Animated.timing(this.animation, {
                toValue: 1,
                duration,
                easing
            }).start(() => {
                const animationIsInProgress = false;
                this.animation = null;
                this.transitionAnimation = this.props.animation ? this.props.animation : TransitionAnimationConfigPresets.none;
                this.setState({
                    animationIsInProgress
                });
                this.oldContent = null;
                this.finishAnimationCallback && this.finishAnimationCallback();
                this.finishAnimationCallback = null;
                var finishCallback;
                var finishCallbacks = this.finishCallbacks.reverse();
                this.finishCallbacks = [];
                while (finishCallback = finishCallbacks.pop()) {
                    finishCallback();
                }
            });
        }
    }
    renderContent() {
        if (this.state.animationIsInProgress) {
            return (React.createElement(View, {style: { flex: 1 }}, 
                React.createElement(Animated.View, {style: this.transitionAnimation.hiding(this.animation, this.layoutRectangle)}, this.oldContent), 
                React.createElement(Animated.View, {style: this.transitionAnimation.appearing(this.animation, this.layoutRectangle)}, this.newContent)));
        }
        else {
            return (React.createElement(View, {style: { flex: 1 }}, this.newContent));
        }
    }
    render() {
        return (React.createElement(View, {style: { flex: 1, overflow: 'hidden' }, onLayout: this.onLayout}, this.renderContent()));
    }
}
export const TransitionAnimationConfigPresets = {
    push: {
        duration: 330,
        easing: Easing.out(Easing.ease),
        hiding: (animatedValue, layout) => {
            const animation = {
                left: 0,
                right: 0,
                top: 0,
                bottom: 0,
                position: 'absolute',
                opacity: animatedValue.interpolate({
                    inputRange: [0, 1],
                    outputRange: [1, 0]
                }),
                transform: [
                    {
                        translateX: animatedValue.interpolate({
                            inputRange: [0, 1],
                            outputRange: [0, -layout.width / 4]
                        })
                    }
                ]
            };
            return animation;
        },
        appearing: (animatedValue, layout) => {
            const animation = {
                left: 0,
                right: 0,
                top: 0,
                bottom: 0,
                position: 'absolute',
                transform: [
                    {
                        translateX: animatedValue.interpolate({
                            inputRange: [0, 1],
                            outputRange: [layout.width, 0]
                        })
                    }
                ]
            };
            return animation;
        }
    },
    pop: {
        duration: 330,
        easing: Easing.out(Easing.ease),
        hiding: (animatedValue, layout) => {
            const animation = {
                left: 0,
                right: 0,
                top: 0,
                bottom: 0,
                position: 'absolute',
                opacity: animatedValue.interpolate({
                    inputRange: [0, 1],
                    outputRange: [1, 0]
                }),
                zIndex: 2,
                transform: [
                    {
                        translateX: animatedValue.interpolate({
                            inputRange: [0, 1],
                            outputRange: [0, layout.width]
                        })
                    }
                ]
            };
            return animation;
        },
        appearing: (animatedValue, layout) => {
            const animation = {
                left: 0,
                right: 0,
                top: 0,
                bottom: 0,
                position: 'absolute',
                zIndex: 1,
                transform: [
                    {
                        translateX: animatedValue.interpolate({
                            inputRange: [0, 1],
                            outputRange: [-layout.width / 4, 0]
                        })
                    }
                ]
            };
            return animation;
        }
    },
    none: {
        duration: 0,
        easing: Easing.linear,
        hiding: (animatedValue, layout) => {
            const animation = {
                flex: 1
            };
            return animation;
        },
        appearing: (animatedValue, layout) => {
            const animation = {
                flex: 1
            };
            return animation;
        }
    },
    fadeInFadeOut: {
        duration: 250,
        easing: Easing.linear,
        hiding: (animatedValue, layout) => {
            const animation = {
                left: 0,
                right: 0,
                top: 0,
                bottom: 0,
                position: 'absolute',
                zIndex: 2,
                opacity: animatedValue.interpolate({
                    inputRange: [0, 1],
                    outputRange: [1, 0]
                })
            };
            return animation;
        },
        appearing: (animatedValue, layout) => {
            const animation = {
                left: 0,
                right: 0,
                top: 0,
                bottom: 0,
                position: 'absolute',
                zIndex: 1,
                opacity: animatedValue.interpolate({
                    inputRange: [0, 1],
                    outputRange: [0, 1]
                })
            };
            return animation;
        }
    }
};
//# sourceMappingURL=UFSTransitionContainer.js.map